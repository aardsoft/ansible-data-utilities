* Filters and inventory manipulation scripts for Ansible              :TOC_4:
  - [[#introduction][Introduction]]
  - [[#includes-for-other-roles][Includes for other roles]]
    - [[#add_ssl_files][add_ssl_files]]
    - [[#install_packages][install_packages]]
  - [[#includes-used-by-basic-host][Includes used by basic-host]]
    - [[#check_versions][check_versions]]
    - [[#manage_hostname][manage_hostname]]
    - [[#manage_nameservices][manage_nameservices]]
    - [[#manage_time][manage_time]]
    - [[#setup_passdb][setup_passdb]]
  - [[#filters][Filters]]
    - [[#boolconv][boolconv]]

** Introduction

This repository hosts some of our publicly available Ansible extensions, as well as some documentation on how we are using Ansible.

The recommended way of using this collection is to include it as a git submodule into your Ansible configuration(s), and adjust plugin search paths in =ansible.cfg=.

Example playbooks to demonstrate how to use the extensions provided here are included in the =playbooks= directory. To run all of them you can execute =ansible-playbook playbooks/all.yml=

** Includes for other roles
*** add_ssl_files

This include handles management of SSL keys and certificates. It can pull keys or certificates from a password store, or generate missing files.

It takes the following variables:

- ssl_size, the size of the SSL key. Defaults to 2048
- ssl_key, the path to the key file
- ssl_certificate, the path to the certificate file
- ssl_key_passdb, a passdb entry containing the SSL key
- ssl_certificate_passdb, a list of passdb entries containing SSL certificates. This allows easy inclusion of intermediaries as well.

If =ssl_certificate= is set without a passdb source a self signed certificate will be generated, if it is missing on disk. This is mostly useful when using services like letsencrypt - this allows bringing up the services with temporary certificates, to be replaced as soon as a system is operable enough to request proper certificates.

Example usage:
#+BEGIN_SRC
- include_role:
    name: data-utilities
    tasks_from: add_ssl_files
  vars:
    ssl_key: /etc/ssl/private/test.key
    ssl_certificate: /etc/ssl/private/test.pem
    ssl_size: 4096
#+END_SRC

When using passdb entries for key and certificates it also is possible to have keys and certificates combined in a single file, specified by =ssl_key=:

#+BEGIN_SRC
- include_role:
    name: data-utilities
    tasks_from: add_ssl_files
  vars:
    ssl_key: /etc/ssl/private/test.pem
    ssl_key_passdb: test-key
    ssl_certificate_passdb:
      - test-cert
      - intermediary
#+END_SRC

Using a single file without passdb entries will result in certificate generation being skipped, which quite likely will lead to failures.

*** install_packages

This include handles package installation for the provided packages on the following distribution/package manager combinations:

- SuSE with zypper
- RedHat/CentOS/Fedora with yum
- RedHat/CentOS/Fedora with dnf
- Debian/Ubuntu with apt

It takes the following variables:

- packages, a list of packages to install.
- install_retries, the number of retries if package installation fails. Defaults to =3=.

Example usage:
#+BEGIN_SRC
- include_role:
    name: data-utilities
    tasks_from: install_packages
  vars:
    install_retries: 10
    packages:
      - nmap
#+END_SRC


** Includes used by basic-host
This section describes includes used by the [[https://github.com/aardsoft/ansible-role-basic-host][basic-host]] role. The documentation here is mainly useful for the variables used to adjust their behaviour - but also may be useful for sites where the complete configuration applied by =basic-host= is not desirable.

*** check_versions

This include checks if the running Ansible version matches the version range this role has been tested with. Additionally it also exports the variable =data_utilities_version=.

The =basic-host= role includes this file, so unless another role needs to use a higher =data-utilities= version than =basic-host= was tested for including this file should not be necessary.

For checking if data utilities is available in the correct version the =data_utilities_minver= variable can be set:

#+BEGIN_SRC
- include_role:
    name: data-utilities
    tasks_from: check_versions
  vars:
    data_utilities_minver: 0.1
  tags:
    - base_config
    - access_setup
#+END_SRC

*** manage_hostname

This include tries to set the system hostname. On Windows this may require a reboot - execution continues once the system is reachable again.

For setting the hostname either the =hostname= variable is used, or - if missing - the hostname is generated from the inventory hostname.

*** manage_nameservices

This include configures name services for a system - this mainly, but not only, covers DNS. Windows currently is not supported.

Nameservers from a list in the variable =nameservers= are used, if available. It usually makes sense to set a default in groupvars for all, and override it for other systems/groups.

There also is some legacy support for copying in prefilled resolv.conf templates based on =resolv_location= and =site_region= settings - this was implemented due to legacy Ansible restriction, and should not be used in new deployments.

*** manage_time

This include configures timezone and other time related settings. On Windows this also sets NTP servers. For Linux this is handled in a separate ntp-client role.

NTP servers are read from a list in the =ntp_servers= variable. This typically should be set in the default groupvars for all, with overrides as needed.

For Windows the timezone is configured in =host_timezone_win=, using [[https://docs.microsoft.com/en-us/previous-versions/windows/embedded/ms912391(v=winembedded.11)][Microsofts time zone names]]. For other system standard TZ database names in the =host_timezone= variable are used.

For all systems the hardware clock is set to UTC.

*** setup_passdb

This initialises the default password store. Variables controlling the setup should be set in group or host variables. the =basic-host= role includes this file - so as long as this role is used there should be no need to include this file.

Available variables are:

- passdb, defaulting to [[https://docs.ansible.com/ansible/latest/collections/community/general/passwordstore_lookup.html][passwordstore]]
- passdb_password_length, default 20. This is used when creating passwords from within Ansible.
- passdb_password_create, bool, default =True=. Configures if Ansible is allowed to create missing passwords.
- passdb_extra_arg, default = create={{passdb_password_create}} length={{passdb_password_length}}=
- passdb_check_value, default empty. Allows setting a record to check if passdb is working. This is useful for writing playbooks executable by both full access admins and people without access to some passwords. A sensible value typically is the entry for the default root password.

The variable =default_passdb_available= will be set by this include:

- =True= if no =passdb_check_value= has been configured. This can lead to errors when executed without correct passdb access permissions.
- =True= if =passdb_check_value= is accessible.
- =False= if =passdb_check_value= is inaccessible.

Tasks/roles should use this variable to guard sections prompting for credentials, or skip execution completely.

** Filters
*** boolconv

This filter takes most of the inputs possible in Ansible to look like a bool, and converts them to a controlled string representation. Recognised inputs are all data which become one of true, false, yes, no, 0 or 1 when passed through Ansible variable expansion into Python.

This solves the problem of Ansible auto-converting yes/no to booleans, and eliminates the chance of having malformed values in configuration files due to forgotten quotes in the variable declaration.

A short example playbook demonstrates this problem with a template containing both defaults and sanitised values:

#+BEGIN_SRC yaml
- template:
    src: boolconv.j2
    dest: .out/boolconv
  vars:
    var1: yes
    var2: "yes"
    var3: true
#+END_SRC

#+BEGIN_EXAMPLE
{{var1}} {{var1|boolconv("yesno")}}
{{var2}} {{var2|boolconv("yesno")}}
{{var3}} {{var3|boolconv("yesno")}}
#+END_EXAMPLE

The output shows that Ansible converts =yes= to a bool, which then becomes =True= when converted back to a string.

#+BEGIN_EXAMPLE
True yes
yes yes
True yes
#+END_EXAMPLE

Note that this also can be a problem for configuration files accepting true/false, but expect them to be lower case. To avoid this issue as well this filter allows controlling case of the output as well. Valid arguments are:

- truefalse
- TrueFalse
- TRUEFALSE
- yesno
- YesNo
- YESNO
- int

The default if no argument is specified is =truefalse=. With a wrong argument as well as inputs not recognisable as one of the values listed above the return value is undefined (typically results in an empty string in Ansible).
